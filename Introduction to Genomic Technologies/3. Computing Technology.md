## 3. Computing Technology

[Key Points](#key-points)

[Study Notes](#study-notes)

## Questions

#### 1. Which of the following best describe the three broad categories of activities in computer science?  
A) Theory, Systems, Applications  
B) Hardware, Software, Networking  
C) Programming, Data Science, Artificial Intelligence  
D) Algorithms, Data Structures, Software Engineering  

#### 2. Computational thinking primarily involves:  
A) Writing code in multiple programming languages  
B) Breaking down problems into precise, executable steps for a computer  
C) Understanding the hardware architecture of computers  
D) Using natural language to communicate with computers  

#### 3. Which of the following are responsibilities of an operating system?  
A) Managing data transfer between disk drives and RAM  
B) Running multiple programs simultaneously on multiprocessor systems  
C) Designing new programming languages  
D) Handling input/output devices like printers and screens  

#### 4. Programming languages differ from natural languages because:  
A) They have ambiguous meanings to allow flexibility  
B) They are highly constrained with specific, unambiguous syntax and semantics  
C) They allow computers to interpret human emotions  
D) They are designed to precisely instruct computers what to do  

#### 5. Why is software engineering critical beyond just writing code that works?  
A) To ensure code handles all possible cases without crashing  
B) To make code run faster than hardware limitations  
C) To maintain code reliability and ease of maintenance  
D) To avoid the need for testing programs  

#### 6. Which of the following statements about algorithms is true?  
A) Algorithms always require a computer to be executed  
B) An algorithm is a complete and precise set of instructions to solve a problem  
C) Bubble sort is the most efficient sorting algorithm for large datasets  
D) Some algorithms find local optima but not necessarily global optima  

#### 7. In the context of sorting algorithms, what is a major drawback of bubble sort?  
A) It does not guarantee a sorted list  
B) It requires complex data structures to operate  
C) It makes many passes through the list, making it inefficient for large data  
D) It only works on numeric data, not text  

#### 8. When storing DNA sequences, why is representing each nucleotide with 2 bits more efficient than 1 byte?  
A) Because DNA has only four letters, which can be encoded in 2 bits  
B) Because 2 bits allow representing more characters than 1 byte  
C) Because it compresses data fourfold, saving storage space  
D) Because computers cannot store bytes efficiently  

#### 9. What is the role of pointers in data structures?  
A) To store the actual data values  
B) To store memory addresses of other data objects  
C) To enable quick navigation between related data in memory  
D) To encrypt data for security purposes  

#### 10. Why might probabilistic models be used to represent biological sequence patterns instead of storing all sequences explicitly?  
A) To compress information from many sequences into a simpler form  
B) To ignore rare variations in sequences  
C) To capture the likelihood of each nucleotide at each position  
D) To avoid using any actual sequence data  

#### 11. Which of the following best illustrates the concept of algorithmic efficiency?  
A) An algorithm that always produces the correct answer regardless of speed  
B) An algorithm that minimizes time and resource use while solving a problem  
C) An algorithm that uses the most memory possible to store data  
D) An algorithm that solves problems only for small datasets  

#### 12. The mail delivery example illustrates which computational problem?  
A) Sorting problem  
B) Traveling Salesman Problem  
C) Maximum finding problem  
D) RNA sequence alignment  

#### 13. Why is software engineering especially important in genomic data analysis?  
A) Because genomic data sets are small and simple  
B) Because rare or unexpected cases can cause software to crash or produce errors  
C) Because software must handle millions of reads without failure  
D) Because software engineering eliminates all bugs automatically  

#### 14. In the RNA editing example, what was a key lesson about software use?  
A) Software always produces perfectly accurate results on big data  
B) Misalignments or errors can lead to false scientific conclusions  
C) Understanding software limitations is critical before interpreting results  
D) RNA editing can be detected without any computational tools  

#### 15. What is a computational biology software pipeline?  
A) A single program that does all data analysis in one step  
B) A series of programs that process raw data through multiple stages to produce interpretable results  
C) A hardware device used to sequence DNA  
D) A method to visualize data without any processing  

#### 16. In RNA-seq analysis, why is a program like TopHat necessary after Bowtie?  
A) To align reads that span splice junctions where introns are removed  
B) To assemble genes from aligned reads  
C) To quantify gene expression levels  
D) To visualize gene expression data  

#### 17. Why must computational biologists keep up with new software versions?  
A) Because older software always crashes on new data  
B) Because different software can produce different results on the same data  
C) Because new software is always faster but less accurate  
D) Because sequencing technologies and data types evolve rapidly  

#### 18. Which of the following statements about alignment programs Bowtie2 and BWA is true?  
A) They always align the exact same reads to the exact same locations  
B) They can differ in which reads they align and where they align them  
C) Differences in alignment are insignificant for biological conclusions  
D) Choosing the fastest aligner guarantees the most accurate results  

#### 19. What does it mean for an algorithm to find a "local maximum" rather than a "global maximum"?  
A) It finds the highest point in the entire dataset  
B) It finds the highest point in the immediate neighborhood but not necessarily overall  
C) It always finds the absolute best solution  
D) It fails to find any maximum at all  

#### 20. Which of the following are challenges when designing data structures for genomic data?  
A) Efficiently storing very large sequences with minimal memory use  
B) Quickly retrieving specific sequences or subsequences from large datasets  
C) Ignoring the physical location of sequences on chromosomes  
D) Compressing data without losing important biological patterns



<br>

## Answers

#### 1. Which of the following best describe the three broad categories of activities in computer science?  
A) ‚úì Theory, Systems, Applications ‚Äî These are the three main categories described.  
B) ‚úó Hardware, Software, Networking ‚Äî These are general computing areas but not the categories given.  
C) ‚úó Programming, Data Science, Artificial Intelligence ‚Äî These are subfields or applications, not the broad categories.  
D) ‚úó Algorithms, Data Structures, Software Engineering ‚Äî These are topics within computer science, not the broad categories.  

**Correct:** A


#### 2. Computational thinking primarily involves:  
A) ‚úó Writing code in multiple programming languages ‚Äî Coding is a skill but not the essence of computational thinking.  
B) ‚úì Breaking down problems into precise, executable steps for a computer ‚Äî This is the core of computational thinking.  
C) ‚úó Understanding the hardware architecture of computers ‚Äî Important but not the main focus of computational thinking.  
D) ‚úó Using natural language to communicate with computers ‚Äî Computers require precise, formal instructions, not natural language.  

**Correct:** B


#### 3. Which of the following are responsibilities of an operating system?  
A) ‚úì Managing data transfer between disk drives and RAM ‚Äî OS handles data movement between storage and memory.  
B) ‚úì Running multiple programs simultaneously on multiprocessor systems ‚Äî OS manages multitasking and multiprocessing.  
C) ‚úó Designing new programming languages ‚Äî This is a separate systems-level activity, not OS responsibility.  
D) ‚úì Handling input/output devices like printers and screens ‚Äî OS manages I/O devices.  

**Correct:** A, B, D


#### 4. Programming languages differ from natural languages because:  
A) ‚úó They have ambiguous meanings to allow flexibility ‚Äî Programming languages are unambiguous.  
B) ‚úì They are highly constrained with specific, unambiguous syntax and semantics ‚Äî This precision is essential for computers.  
C) ‚úó They allow computers to interpret human emotions ‚Äî Programming languages do not handle emotions.  
D) ‚úì They are designed to precisely instruct computers what to do ‚Äî This is their fundamental purpose.  

**Correct:** B, D


#### 5. Why is software engineering critical beyond just writing code that works?  
A) ‚úì To ensure code handles all possible cases without crashing ‚Äî Robustness is key in software engineering.  
B) ‚úó To make code run faster than hardware limitations ‚Äî Hardware limits cannot be exceeded by software engineering.  
C) ‚úì To maintain code reliability and ease of maintenance ‚Äî Software engineering includes maintainability.  
D) ‚úó To avoid the need for testing programs ‚Äî Testing is a core part of software engineering, not avoided.  

**Correct:** A, C


#### 6. Which of the following statements about algorithms is true?  
A) ‚úó Algorithms always require a computer to be executed ‚Äî Algorithms can be executed by humans or machines.  
B) ‚úì An algorithm is a complete and precise set of instructions to solve a problem ‚Äî This is the definition of an algorithm.  
C) ‚úó Bubble sort is the most efficient sorting algorithm for large datasets ‚Äî Bubble sort is inefficient for large data.  
D) ‚úì Some algorithms find local optima but not necessarily global optima ‚Äî Example: hill climbing algorithm.  

**Correct:** B, D


#### 7. In the context of sorting algorithms, what is a major drawback of bubble sort?  
A) ‚úó It does not guarantee a sorted list ‚Äî Bubble sort always sorts correctly.  
B) ‚úó It requires complex data structures to operate ‚Äî Bubble sort works on simple lists.  
C) ‚úì It makes many passes through the list, making it inefficient for large data ‚Äî This is the main inefficiency.  
D) ‚úó It only works on numeric data, not text ‚Äî Bubble sort can sort any comparable data.  

**Correct:** C


#### 8. When storing DNA sequences, why is representing each nucleotide with 2 bits more efficient than 1 byte?  
A) ‚úì Because DNA has only four letters, which can be encoded in 2 bits ‚Äî Four letters fit exactly in 2 bits.  
B) ‚úó Because 2 bits allow representing more characters than 1 byte ‚Äî 1 byte can represent more characters than 2 bits.  
C) ‚úì Because it compresses data fourfold, saving storage space ‚Äî 8 bits to 2 bits is 4x compression.  
D) ‚úó Because computers cannot store bytes efficiently ‚Äî Computers store bytes efficiently; this is about compression.  

**Correct:** A, C


#### 9. What is the role of pointers in data structures?  
A) ‚úó To store the actual data values ‚Äî Pointers store addresses, not data itself.  
B) ‚úì To store memory addresses of other data objects ‚Äî This is the definition of a pointer.  
C) ‚úì To enable quick navigation between related data in memory ‚Äî Pointers link data for efficient access.  
D) ‚úó To encrypt data for security purposes ‚Äî Pointers do not encrypt data.  

**Correct:** B, C


#### 10. Why might probabilistic models be used to represent biological sequence patterns instead of storing all sequences explicitly?  
A) ‚úì To compress information from many sequences into a simpler form ‚Äî Probabilistic models summarize patterns efficiently.  
B) ‚úó To ignore rare variations in sequences ‚Äî Models capture probabilities, not ignore rare events entirely.  
C) ‚úì To capture the likelihood of each nucleotide at each position ‚Äî This is the core idea of sequence logos.  
D) ‚úó To avoid using any actual sequence data ‚Äî Models are derived from sequence data, not avoiding it.  

**Correct:** A, C


#### 11. Which of the following best illustrates the concept of algorithmic efficiency?  
A) ‚úó An algorithm that always produces the correct answer regardless of speed ‚Äî Correctness alone is not efficiency.  
B) ‚úì An algorithm that minimizes time and resource use while solving a problem ‚Äî Efficiency balances correctness and resource use.  
C) ‚úó An algorithm that uses the most memory possible to store data ‚Äî Using more memory is inefficient.  
D) ‚úó An algorithm that solves problems only for small datasets ‚Äî Efficiency is especially important for large datasets.  

**Correct:** B


#### 12. The mail delivery example illustrates which computational problem?  
A) ‚úó Sorting problem ‚Äî Mail delivery is not about sorting.  
B) ‚úì Traveling Salesman Problem ‚Äî Finding the shortest route visiting multiple locations.  
C) ‚úó Maximum finding problem ‚Äî Not related to route optimization.  
D) ‚úó RNA sequence alignment ‚Äî Unrelated to mail delivery.  

**Correct:** B


#### 13. Why is software engineering especially important in genomic data analysis?  
A) ‚úó Because genomic data sets are small and simple ‚Äî They are large and complex.  
B) ‚úì Because rare or unexpected cases can cause software to crash or produce errors ‚Äî Large data sets expose rare edge cases.  
C) ‚úì Because software must handle millions of reads without failure ‚Äî Scalability and robustness are critical.  
D) ‚úó Because software engineering eliminates all bugs automatically ‚Äî Bugs can still exist despite good engineering.  

**Correct:** B, C


#### 14. In the RNA editing example, what was a key lesson about software use?  
A) ‚úó Software always produces perfectly accurate results on big data ‚Äî Errors can occur even in well-engineered software.  
B) ‚úì Misalignments or errors can lead to false scientific conclusions ‚Äî Misinterpretation due to software errors is a risk.  
C) ‚úì Understanding software limitations is critical before interpreting results ‚Äî Knowing software behavior is essential.  
D) ‚úó RNA editing can be detected without any computational tools ‚Äî Computational tools are necessary for large-scale detection.  

**Correct:** B, C


#### 15. What is a computational biology software pipeline?  
A) ‚úó A single program that does all data analysis in one step ‚Äî Pipelines involve multiple programs in sequence.  
B) ‚úì A series of programs that process raw data through multiple stages to produce interpretable results ‚Äî This is the definition of a pipeline.  
C) ‚úó A hardware device used to sequence DNA ‚Äî Pipelines are software workflows, not hardware.  
D) ‚úó A method to visualize data without any processing ‚Äî Visualization is usually a later step after processing.  

**Correct:** B


#### 16. In RNA-seq analysis, why is a program like TopHat necessary after Bowtie?  
A) ‚úì To align reads that span splice junctions where introns are removed ‚Äî TopHat handles spliced alignments.  
B) ‚úó To assemble genes from aligned reads ‚Äî This is done by Cufflinks, not TopHat.  
C) ‚úó To quantify gene expression levels ‚Äî Also done by Cufflinks.  
D) ‚úó To visualize gene expression data ‚Äî Visualization is separate from alignment.  

**Correct:** A


#### 17. Why must computational biologists keep up with new software versions?  
A) ‚úó Because older software always crashes on new data ‚Äî Not always, but may be less accurate or slower.  
B) ‚úì Because different software can produce different results on the same data ‚Äî Software choice affects outcomes.  
C) ‚úó Because new software is always faster but less accurate ‚Äî New software can be both faster and more accurate.  
D) ‚úì Because sequencing technologies and data types evolve rapidly ‚Äî Software must adapt to new data types.  

**Correct:** B, D


#### 18. Which of the following statements about alignment programs Bowtie2 and BWA is true?  
A) ‚úó They always align the exact same reads to the exact same locations ‚Äî They differ in alignments and locations.  
B) ‚úì They can differ in which reads they align and where they align them ‚Äî This is observed in practice.  
C) ‚úó Differences in alignment are insignificant for biological conclusions ‚Äî Differences can be critical.  
D) ‚úó Choosing the fastest aligner guarantees the most accurate results ‚Äî Speed does not guarantee accuracy.  

**Correct:** B


#### 19. What does it mean for an algorithm to find a "local maximum" rather than a "global maximum"?  
A) ‚úó It finds the highest point in the entire dataset ‚Äî That is a global maximum.  
B) ‚úì It finds the highest point in the immediate neighborhood but not necessarily overall ‚Äî This is a local maximum.  
C) ‚úó It always finds the absolute best solution ‚Äî Local maxima may not be the best overall.  
D) ‚úó It fails to find any maximum at all ‚Äî It does find a maximum, just not necessarily the global one.  

**Correct:** B


#### 20. Which of the following are challenges when designing data structures for genomic data?  
A) ‚úì Efficiently storing very large sequences with minimal memory use ‚Äî Large data requires efficient storage.  
B) ‚úì Quickly retrieving specific sequences or subsequences from large datasets ‚Äî Fast access is critical.  
C) ‚úó Ignoring the physical location of sequences on chromosomes ‚Äî Location is important metadata.  
D) ‚úì Compressing data without losing important biological patterns ‚Äî Compression must preserve key information.  

**Correct:** A, B, D



<br>

## Key Points

#### 1. üíª Computer Science Categories  
- Computer science is divided into Theory, Systems, and Applications.  
- Theory studies what problems computers can solve.  
- Systems focus on building software like operating systems and programming languages.  
- Applications involve using computers to solve real-world problems, often outside core computer science.

#### 2. üñ•Ô∏è Operating Systems and Systems-Level Computing  
- UNIX is a mature operating system used under Mac computers, existing for over 30 years.  
- Operating systems manage data transfer between disk drives and RAM.  
- They handle running multiple programs simultaneously on multiprocessor computers.  

#### 3. üìù Programming Languages  
- Programming languages are highly constrained, precise languages for instructing computers.  
- Popular languages include Python, Perl, C++, and Java.  
- Programming languages differ fundamentally from natural languages like English.

#### 4. üõ†Ô∏è Software Engineering  
- Writing code requires testing to ensure it works in all cases and does not crash.  
- Programs must handle unexpected inputs (e.g., division by zero) to avoid errors.  
- Reliable software engineering is critical for genomic data analysis.

#### 5. üîç Algorithms  
- An algorithm is a complete, step-by-step set of instructions to solve a problem.  
- Algorithms do not require computers; examples include recipes.  
- The "hill climbing" algorithm finds a local maximum by moving uphill stepwise but may not find the global maximum.  
- Bubble sort is a simple sorting algorithm that repeatedly swaps adjacent out-of-order items until sorted.  
- Bubble sort is guaranteed to sort but is inefficient compared to other sorting algorithms.

#### 6. üóÉÔ∏è Data Structures and Memory  
- Data structures organize data efficiently for storage and retrieval, important for large datasets like genomes.  
- DNA sequences can be stored more efficiently by encoding each nucleotide with 2 bits instead of 8 bits (one byte), achieving fourfold compression.  
- Common data structures include lists, linked lists, and trees.  
- Pointers store memory addresses and allow linking between data objects.  
- Probabilistic models can represent biological sequence patterns more compactly than storing all sequences explicitly.

#### 7. ‚ö° Algorithmic Efficiency  
- Efficient algorithms minimize time and resource use, especially important for big data.  
- The mail delivery example illustrates inefficiency when repeatedly returning to a warehouse instead of delivering multiple mails per trip.  
- The Traveling Salesman Problem models finding the shortest route visiting multiple locations efficiently.

#### 8. üß¨ Computational Biology Software and Pipelines  
- Computational biology software transforms raw DNA/RNA sequence data into interpretable biological information.  
- Analysis pipelines consist of multiple programs that process data stepwise (e.g., cleaning, aligning, assembling).  
- The Tuxedo pipeline for RNA-seq includes Bowtie (alignment), TopHat (splice-aware alignment), and Cufflinks (assembly and quantification).  
- Newer tools like Bowtie2, HISAT, StringTie, and Ballgown improve speed and accuracy over older tools.  
- Different software tools can produce different results on the same data, affecting biological conclusions.

#### 9. üîÑ Software Reliability and Limitations  
- Even well-engineered software can produce errors on large datasets due to rare edge cases.  
- RNA editing detection can be confounded by alignment errors from software.  
- Software that runs without crashing may still produce misleading results if not carefully validated.  
- Keeping software updated with evolving sequencing technology is essential to avoid incorrect conclusions.



<br>

## Study Notes

### 1. üíª What is Computer Science? Understanding the Big Picture

Computer Science is a broad field that involves many different activities related to computers and computation. To make sense of this diversity, computer science is often divided into three main categories:

- **Theory:** This area focuses on the fundamental questions about what computers can do. It studies the kinds of problems that can be solved by computers and how efficiently they can be solved. Theory is about understanding the limits and capabilities of computation itself.

- **Systems:** This area deals with the actual computers and the software that runs on them. It includes building operating systems (the software that manages the computer‚Äôs hardware and resources), designing programming languages (the languages we use to write software), and managing how programs run on computers, especially in complex environments like multiprocessor systems.

- **Applications:** This is the broadest category and involves using computers to solve real-world problems. Applications can be in science, business, medicine, and many other fields. As computer science has matured, many applications have become specialized and sometimes are considered separate fields.

#### Thinking Computationally

A key skill in computer science is **computational thinking**. This means approaching problems by breaking them down into precise, step-by-step tasks that a computer can perform. Unlike human communication, computers do exactly what they are told‚Äîno more, no less‚Äîso instructions must be very clear and unambiguous. Computational thinking is not just about programming; it‚Äôs about understanding how to translate a problem into a form that a computer can handle.


### 2. üñ•Ô∏è Systems in Computer Science: Operating Systems and Programming Languages

#### Operating Systems

Operating systems (OS) are the foundational software that manage a computer‚Äôs hardware and provide services for other software. For example, if you are using a Mac, underneath it runs an OS called **UNIX**, which is one of the oldest and most stable operating systems, existing for over 30 years.

The OS handles many critical tasks:

- Moving data between storage devices (like hard drives) and the computer‚Äôs fast internal memory (RAM).
- Loading and running programs.
- Managing input/output devices like screens and printers.
- Handling multiple processors and allowing multiple programs to run simultaneously without crashing.

#### Programming Languages

Programming languages are how we communicate instructions to computers. Unlike natural languages (like English), programming languages are very strict and precise. Each word or symbol has a specific meaning, and the computer executes exactly what the code says.

There are many programming languages, each with different strengths. Some popular ones today include:

- **Python:** Known for simplicity and readability.
- **Perl:** Often used for text processing.
- **C++ and Java:** Used for more complex, performance-critical applications.

Learning a programming language is learning how to give precise instructions to a computer.

#### Software Engineering

Writing code is not just about making it work once. **Software engineering** is the discipline of writing code that is reliable, maintainable, and tested thoroughly. Good software engineering involves:

- Testing code to ensure it works in all expected cases.
- Handling unexpected or rare cases gracefully (e.g., avoiding crashes).
- Making sure the program behaves robustly and efficiently.

For example, a program should never crash or freeze your computer, even if it encounters unusual input.

#### Hardware and Devices

Beyond software, computer science also involves understanding the **hardware**‚Äîthe physical devices that run software. Today, computers are everywhere, from laptops and desktops to mobile phones and robots. Many devices are controlled by embedded computers, and understanding how software interacts with hardware is an important part of computer science.


### 3. üîç Algorithms: Step-by-Step Instructions for Solving Problems

An **algorithm** is a clear, step-by-step set of instructions for accomplishing a task. Algorithms are fundamental to computer science because they describe what a computer can do.

#### Algorithms Don‚Äôt Need Computers

Interestingly, algorithms exist independently of computers. For example, a recipe for making brownies is an algorithm: it tells you exactly what steps to follow to get the final product. As long as you understand the instructions, you can follow the algorithm.

#### Example: Finding a Maximum

Imagine you want to find the highest point in a landscape. One simple algorithm is:

- Look around and find the direction where the slope is steepest uphill.
- Take a step in that direction.
- Repeat until you can no longer go uphill.

This algorithm will find the nearest peak, but not necessarily the highest peak overall. This illustrates that some algorithms find local optima rather than global optima.

#### Example: Sorting

Sorting is a common problem where you want to arrange items in order (e.g., numbers from smallest to largest).

One simple sorting algorithm is **bubble sort**:

- Start at the beginning of the list.
- Compare each pair of adjacent items.
- If they are in the wrong order, swap them.
- Repeat this process, going back to the start each time, until the entire list is sorted.

Bubble sort always works but is inefficient for large lists because it makes many passes through the data. This introduces the idea of **algorithmic efficiency**‚Äîsome algorithms solve problems faster or with less resource use than others.


### 4. üóÉÔ∏è Data Structures and Memory: Organizing and Storing Data Efficiently

Data structures are ways to organize and store data in a computer so that it can be accessed and modified efficiently. This is especially important when dealing with very large datasets, such as genomic sequences.

#### Storing Genomic Data

Genomic data often comes as long strings of letters (A, C, G, T) representing DNA sequences. Computers store text as bytes, where each character typically takes one byte (8 bits).

However, DNA only has four letters, so we can store each letter using just 2 bits instead of 8, achieving a **fourfold compression**. For example:

- A = 00
- C = 01
- G = 10
- T = 11

This compression is crucial when storing gigabytes or terabytes of DNA data.

#### Common Data Structures

- **Lists:** Simple sequences of items.
- **Linked lists:** Lists where each item points to the next, allowing efficient insertion and deletion.
- **Trees:** Hierarchical structures where each item can point to multiple others, useful for organizing data with relationships.

#### Pointers and Memory Addresses

In computer memory, every piece of data has an **address**. A **pointer** is a variable that stores the address of another piece of data. Using pointers, data structures can link related pieces of data together, enabling quick navigation through large datasets.

#### Representing Biological Patterns

Sometimes, instead of storing every sequence explicitly, we store patterns or probabilistic models. For example, introns (non-coding regions in genes) have characteristic start and end sequences (GT at the start, AG at the end). By analyzing many introns, we can create a **probabilistic model** showing the likelihood of each nucleotide at each position, compressing the information and helping us recognize these patterns in new data.


### 5. ‚ö° Algorithmic Efficiency: Why Speed and Resource Use Matter

Efficiency is about how fast and how resourcefully an algorithm solves a problem, especially important when working with big data like genomics.

#### Example: Mail Delivery Problem

Imagine a mail truck delivering mail:

- A simple algorithm: pick up mail for one house, deliver it, return to warehouse, repeat for each house.
- This works but is inefficient because the truck travels back and forth unnecessarily.

A better algorithm would:

- Load mail for many houses at once.
- Deliver mail to houses in a route that minimizes travel distance.
- Return to warehouse only when the truck is empty.

This is related to the **Traveling Salesman Problem**, a classic problem in computer science about finding the shortest possible route visiting a set of locations.

#### Why Efficiency Matters

When algorithms are inefficient, they waste time and resources. With large datasets, inefficient algorithms can become impractical. Therefore, computer scientists strive to design algorithms that solve problems correctly **and** efficiently.


### 6. üõ†Ô∏è Software Engineering in Genomic Data Science: Writing Reliable Code

Software engineering is the practice of writing code that is not only functional but also reliable, maintainable, and robust.

#### Handling Edge Cases

Programs must handle all possible inputs, including rare or unexpected cases. For example, in a program that divides two numbers, you must check that the denominator is not zero to avoid crashes.

#### Importance in Genomics

Genomic datasets are huge and complex, so software must be carefully engineered to handle all cases without crashing or producing misleading results.

#### Example: RNA Editing and Software Reliability

RNA editing is a biological process where some RNA nucleotides are changed after transcription. Detecting RNA editing involves aligning RNA sequences to DNA sequences and looking for differences.

- Some researchers found thousands of new RNA editing sites using alignment software.
- However, many of these differences were due to software errors or misalignments.
- This shows that even well-engineered software can produce errors on big datasets.
- It‚Äôs critical to understand how software works and to verify results carefully.


### 7. üß¨ Computational Biology Software: From Raw Data to Biological Insights

Computational biology software transforms raw biological data into meaningful information.

#### Raw Data to Information

Raw data from genome sequencing is just long strings of letters (A, C, G, T) that are hard to interpret. Software pipelines process this data through multiple steps to produce results that biologists can understand and use.

#### Analysis Pipelines

A **pipeline** is a series of software tools that process data step-by-step. For example, in RNA sequencing (RNA-seq):

- **Bowtie:** Aligns short RNA reads to the genome.
- **TopHat:** Handles reads that span splice junctions (where RNA is cut and rejoined).
- **Cufflinks:** Assembles aligned reads into genes and estimates gene expression levels.
- **Cuffdiff:** Compares gene expression between samples.

These tools together convert raw RNA sequence data into a list of genes and their expression levels, which can be used to study biological differences.

#### Keeping Up with Software

Software tools evolve rapidly. Newer versions (e.g., Bowtie2, HISAT, StringTie, Ballgown) improve speed and accuracy. Different tools can produce different results, so computational biologists must stay informed about the latest software and understand their strengths and limitations.


### 8. üîÑ The Changing Landscape: Technology and Software Evolution

Sequencing technology and computational biology software are both advancing quickly:

- New sequencing machines produce longer and more complex reads.
- Software must adapt to handle new data types and larger volumes.
- Using outdated software on new data can lead to incorrect results.
- Continuous learning and updating software tools are essential for accurate analysis.


### Summary

Computer science is a vast field encompassing theory, systems, and applications. Computational thinking is essential for solving problems with computers. Systems include operating systems and programming languages, while software engineering ensures code reliability. Algorithms are step-by-step instructions, and their efficiency is crucial for handling big data. Data structures organize data efficiently, especially in genomics where compression and pattern recognition are important. Computational biology software pipelines transform raw sequencing data into meaningful biological insights, but software must be carefully engineered and constantly updated to keep pace with evolving technology.